{% extends "header.html" %}

{% block title %}Upload Files{% endblock %}

{% block content %}
<div class="card mb-4">
    <div class="card-header">
        <h5 class="mb-0">Upload Files</h5>
    </div>
    <div class="card-body">
        <form id="uploadForm" action="/upload-big-size" method="POST" enctype="multipart/form-data">
            <div class="mb-3">
                <label for="flag" class="form-label">Select a Flag</label>
                <small class="text-danger">*Required</small> 
                <select name="flag" class="form-select" required>
                    <option value="" disabled selected>Select a flag</option>
                    {% for flag in flags %}
                    <option value="{{ flag }}">{{ flag }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="mb-3">
                <div class="d-flex flex-column">
                    <div class="d-flex align-items-center mb-1">
                        <label for="file" class="form-label me-2">Select Text File(s)</label>
                        <small class="text-danger">*Maksimal size file upload 200MB</small> 
                    </div>
                    <small class="text-success">
                        <i class="fas fa-exclamation-triangle"></i> Pastikan file yang diupload memiliki <strong>NPWP</strong> atau <strong>Nomor Identitas</strong> yang sama. Jika tidak sama, sistem <u>tidak akan memproses</u> file tersebut.
                    </small>
                </div>
                <input type="file" name="file" class="form-control mt-2" accept=".txt" multiple required>
            </div>
            <div class="mb-3">
                <label for="nama_file" class="form-label">Nama File</label>
                <small class="text-danger">*Required</small> 
                <input type="text" id="nama_file" name="nama_file" class="form-control" required>
                <div id="filename-error" class="text-danger mt-1" style="display: none;">
                    <small><i class="fas fa-exclamation-triangle"></i> Nama file sudah ada, harap masukkan nama file yang lain</small>
                </div>
            </div>
            <button type="submit" id="submitBtn" class="btn btn-primary">Upload</button>    
        </form>
    </div>
</div>

<div class="card mt-4">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">Data Upload</h5>
        <a href="{{ url_for('upload_big_size_file') }}" class="btn btn-info btn-sm">
            <i class="fas fa-sync-alt"></i> Refresh
        </a>
    </div>
    <div class="card-body">
        <div class="table-responsive" style="overflow-x: auto;">
            <table id="uploadTable" class="table table-bordered nowrap w-100">
                <thead>
                    <tr>
                        <th>Nama File Upload</th>
                        <th>Periode Data</th>
                        <th>Upload Date</th>
                        <th>Status</th>
                        <th>Download</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Data will be loaded via AJAX -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Toast Notification -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 9999">
    <div id="uploadToast" class="toast align-items-center text-white bg-info border-0" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="d-flex">
            <div class="toast-body">
                <i class="fas fa-spinner fa-spin me-2"></i> Upload sedang diproses...
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
    </div>
</div>

<!-- Script di dalam template upload_big_size.html -->

<script>
// ==================== BACKEND DATA ====================
const tasksFromBackend = {{ tasksFromBackend | tojson | safe }} || [];
const taskId = {% if task_id %}"{{ task_id }}"{% else %}null{% endif %};

console.log('üìã Initial tasks from backend:', tasksFromBackend);
console.log('üéØ Current task ID:', taskId);
</script>

<script>
// ==================== GLOBAL STATE ====================
let dataTable = null;
let taskMetadataCache = {};
let completedTasks = new Set();
let activePollingTasks = new Map();
let dataTableAbortController = null;

const CONFIG = {
    DATATABLE_TIMEOUT: 10000,
    POLLING_FAST_INTERVAL: 1000,
    POLLING_SLOW_INTERVAL: 3000,
    POLLING_TIMEOUT: 8000,
    MAX_POLLING_ERRORS: 3
};

// ==================== UTILITY FUNCTIONS ====================

function showToast(message, type = 'success') {
    const toastEl = document.getElementById('uploadToast');
    const toastBody = toastEl.querySelector('.toast-body');

    toastEl.classList.remove('bg-success', 'bg-danger', 'bg-warning', 'bg-info');
    
    const icons = {
        error: 'times-circle',
        warning: 'exclamation-triangle',
        info: 'info-circle',
        success: 'check-circle'
    };
    
    const bgClasses = {
        error: 'bg-danger',
        warning: 'bg-warning',
        info: 'bg-info',
        success: 'bg-success'
    };
    
    toastEl.classList.add(bgClasses[type] || 'bg-info');
    toastBody.innerHTML = `<i class="fas fa-${icons[type]} me-2"></i>${message}`;
    
    new bootstrap.Toast(toastEl, { delay: 5000 }).show();
}

function cleanupAllRequests() {
    console.log('üßπ Cleaning up requests');
    
    if (dataTableAbortController) {
        try { dataTableAbortController.abort(); } catch (e) {}
        dataTableAbortController = null;
    }
    
    activePollingTasks.forEach((state, taskId) => {
        try {
            if (state.controller) state.controller.abort();
        } catch (e) {}
    });
}

// ==================== PROGRESS UI ====================

function updateProgressUI(taskId, data) {
    const progress = Math.min(Math.max(data.progress || 0, 0), 100);
    const status = data.status || 'processing';
    const message = data.message || '';
    
    // PERBAIKAN: Cari dengan data-task-id attribute
    let progressBar = document.querySelector(`[data-task-id="${taskId}"]`);
    
    if (!progressBar) {
        console.warn(`‚ö†Ô∏è Progress bar not found for task: ${taskId}`);
        return;
    }
    
    // Update progress
    progressBar.style.width = `${progress}%`;
    progressBar.setAttribute('aria-valuenow', progress);
    progressBar.innerText = message && progress < 100 ? 
        `${progress}% - ${message}` : 
        (status === 'error' ? 'Error' : `${progress}%`);
    
    // Update classes
    progressBar.classList.toggle('progress-bar-animated', progress < 100 && status !== 'error');
    progressBar.classList.toggle('progress-bar-striped', progress < 100 && status !== 'error');
    progressBar.classList.toggle('bg-danger', status === 'error');
    progressBar.classList.toggle('bg-success', status === 'completed' && progress === 100);
    
    // Update button
    const downloadBtn = document.querySelector(`button[data-task-id="${taskId}"]`);
    if (downloadBtn && progress < 100 && status !== 'error') {
        downloadBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${progress}%`;
    }
}

function handleTaskSuccess(taskId) {
    const progressBar = document.querySelector(`[data-task-id="${taskId}"]`);
    if (progressBar) {
        progressBar.classList.remove('progress-bar-animated', 'progress-bar-striped');
        progressBar.style.width = '100%';
        progressBar.innerText = '100%';
    }
    
    const downloadBtn = document.querySelector(`button[data-task-id="${taskId}"]`);
    if (downloadBtn && taskMetadataCache[taskId]) {
        const meta = taskMetadataCache[taskId];
        const params = new URLSearchParams({
            periodeData: meta.periodeData || '',
            username: meta.username || '',
            namaFileUpload: meta.namaFileUpload || '',
            uploadDate: meta.uploadDate || ''
        });
        
        downloadBtn.outerHTML = `
            <div class="btn-group">
                <a href="/download-big-size?${params}" class="btn btn-outline-success btn-sm">
                    Excel <i class="fas fa-file-excel"></i>
                </a>
                <a href="/download_upload?${params}" class="btn btn-outline-primary btn-sm">
                    ZIP <i class="fas fa-file-archive"></i>
                </a>
            </div>
        `;
    }
}

function handleTaskError(taskId, message) {
    const progressBar = document.querySelector(`[data-task-id="${taskId}"]`);
    if (progressBar) {
        progressBar.classList.remove('progress-bar-animated', 'progress-bar-striped');
        progressBar.classList.add('bg-danger');
        progressBar.style.width = '100%';
        progressBar.innerText = 'Error';
    }
    
    const downloadBtn = document.querySelector(`button[data-task-id="${taskId}"]`);
    if (downloadBtn) {
        downloadBtn.disabled = true;
        downloadBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Error';
        downloadBtn.className = 'btn btn-danger btn-sm';
    }
}

// ==================== ADAPTIVE POLLING ====================

function startAdaptivePolling(taskId) {
    // PERBAIKAN: Check jika sudah polling atau completed
    if (activePollingTasks.has(taskId)) {
        console.log(`‚úì Already polling: ${taskId}`);
        return;
    }
    
    if (completedTasks.has(taskId)) {
        console.log(`‚úì Task ${taskId} already completed`);
        return;
    }
    
    console.log(`üöÄ Starting polling: ${taskId}`);
    
    const pollingState = {
        controller: null,
        startTime: Date.now(),
        consecutiveErrors: 0,
        lastProgress: 0
    };
    
    activePollingTasks.set(taskId, pollingState);
    
    function poll() {
        if (completedTasks.has(taskId)) {
            console.log(`‚úÖ Task ${taskId} completed`);
            activePollingTasks.delete(taskId);
            return;
        }
        
        const abortController = new AbortController();
        pollingState.controller = abortController;
        
        const timeoutId = setTimeout(() => abortController.abort(), CONFIG.POLLING_TIMEOUT);
        
        fetch(`/progress-status/${taskId}`, {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' },
            signal: abortController.signal
        })
        .then(response => {
            clearTimeout(timeoutId);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.json();
        })
        .then(data => {
            pollingState.consecutiveErrors = 0;
            pollingState.lastProgress = data.progress || 0;
            
            console.log(`üìä ${taskId}: ${data.progress}% - ${data.status}`);
            
            // Cache metadata
            if (data.metadata) {
                taskMetadataCache[taskId] = data.metadata;
            }
            
            // Update UI
            updateProgressUI(taskId, data);
            
            // Check completion
            if (data.completed) {
                console.log(`‚úÖ Task ${taskId} completed - Status: ${data.status}`);
                completedTasks.add(taskId);
                activePollingTasks.delete(taskId);
                
                if (data.error) {
                    handleTaskError(taskId, data.message);
                    showToast(data.message, 'error');
                } else {
                    handleTaskSuccess(taskId);
                    showToast('File berhasil diproses!', 'success');
                    
                    // Reload DataTable
                    setTimeout(() => {
                        if (dataTable) {
                            console.log('üîÑ Reloading DataTable after completion');
                            dataTable.ajax.reload(null, false);
                        }
                    }, 2000);
                }
                return;
            }
            
            // Continue polling
            const interval = data.progress > 50 ? 
                CONFIG.POLLING_SLOW_INTERVAL : 
                CONFIG.POLLING_FAST_INTERVAL;
            
            setTimeout(poll, interval);
        })
        .catch(err => {
            clearTimeout(timeoutId);
            
            if (err.name === 'AbortError') {
                console.log(`‚è∏Ô∏è Polling aborted: ${taskId}`);
                activePollingTasks.delete(taskId);
                return;
            }
            
            console.error(`‚ùå Polling error: ${taskId}`, err.message);
            pollingState.consecutiveErrors++;
            
            if (pollingState.consecutiveErrors >= CONFIG.MAX_POLLING_ERRORS) {
                console.error(`üõë Max errors for ${taskId}`);
                completedTasks.add(taskId);
                activePollingTasks.delete(taskId);
                handleTaskError(taskId, 'Connection error');
                return;
            }
            
            // Exponential backoff
            const backoff = Math.min(
                CONFIG.POLLING_SLOW_INTERVAL * Math.pow(2, pollingState.consecutiveErrors - 1),
                15000
            );
            
            setTimeout(poll, backoff);
        });
    }
    
    poll();
}

// ==================== EXTRACT & RESUME POLLING ====================

function extractAndResumePolling(inProgressTasksFromAPI = []) {
    /**
     * PERBAIKAN CRITICAL:
     * 1. Gunakan task IDs dari API response (inProgressTasks)
     * 2. Fallback ke DOM jika API tidak return task IDs
     * 3. Resume polling untuk semua active tasks
     */
    
    console.log('üîç Extracting and resuming polling');
    
    const tasksToResume = new Set();
    
    // PERBAIKAN #1: Prioritas task IDs dari API
    if (inProgressTasksFromAPI && inProgressTasksFromAPI.length > 0) {
        console.log(`üìã Got ${inProgressTasksFromAPI.length} tasks from API:`, inProgressTasksFromAPI);
        inProgressTasksFromAPI.forEach(tid => tasksToResume.add(tid));
    }
    
    // PERBAIKAN #2: Fallback ke DOM scan
    const progressBars = document.querySelectorAll('[data-task-id]');
    console.log(`üîé Found ${progressBars.length} progress bars in DOM`);
    
    progressBars.forEach(bar => {
        const taskId = bar.getAttribute('data-task-id');
        const progressWidth = bar.style.width;
        const progress = parseInt(progressWidth) || 0;
        
        if (taskId && progress < 100) {
            tasksToResume.add(taskId);
            console.log(`üìå Found incomplete task in DOM: ${taskId} (${progress}%)`);
        }
    });
    
    // PERBAIKAN #3: Resume polling untuk semua tasks
    console.log(`üéØ Tasks to resume: ${tasksToResume.size}`, Array.from(tasksToResume));
    
    tasksToResume.forEach(taskId => {
        if (!activePollingTasks.has(taskId) && !completedTasks.has(taskId)) {
            console.log(`üîÑ Resuming polling for: ${taskId}`);
            startAdaptivePolling(taskId);
        } else {
            console.log(`‚è≠Ô∏è Skipping ${taskId} - already polling or completed`);
        }
    });
    
    console.log(`‚úÖ Polling status: ${activePollingTasks.size} active, ${completedTasks.size} completed`);
}

// ==================== DATATABLE ====================

$(document).ready(function() {
    try {
        if ($.fn.DataTable.isDataTable('#uploadTable')) {
            $('#uploadTable').DataTable().destroy();
        }

        dataTable = $('#uploadTable').DataTable({
            processing: true,
            serverSide: true,
            ajax: {
                url: '/api/upload-data',
                type: 'GET',
                timeout: CONFIG.DATATABLE_TIMEOUT,
                beforeSend: function(xhr) {
                    if (dataTableAbortController) {
                        try { dataTableAbortController.abort(); } catch (e) {}
                    }
                    dataTableAbortController = new AbortController();
                    
                    const timeoutId = setTimeout(() => {
                        if (dataTableAbortController) dataTableAbortController.abort();
                    }, CONFIG.DATATABLE_TIMEOUT);
                    
                    xhr.timeoutId = timeoutId;
                },
                complete: function(xhr) {
                    if (xhr.timeoutId) clearTimeout(xhr.timeoutId);
                },
                // PERBAIKAN: Process response untuk extract task IDs
                dataSrc: function(json) {
                    console.log('üì• DataTable response:', json);
                    
                    // CRITICAL: Extract in-progress tasks dari response
                    const inProgressTasks = json.inProgressTasks || [];
                    
                    if (inProgressTasks.length > 0) {
                        console.log(`üéØ API returned ${inProgressTasks.length} in-progress tasks`);
                        
                        // Store untuk use di drawCallback
                        dataTable.inProgressTasks = inProgressTasks;
                    }
                    
                    return json.data;
                },
                error: function(xhr, error, code) {
                    if (error === 'abort') {
                        console.log('‚úÖ DataTable aborted (normal on refresh)');
                        return;
                    }
                    
                    if (error === 'timeout' || xhr.status === 504) {
                        console.warn('‚è±Ô∏è DataTable timeout');
                        showToast('Loading timeout', 'warning');
                        return;
                    }
                    
                    if (xhr.status >= 500) {
                        console.error('‚ùå Server error:', xhr.status);
                        showToast('Server error', 'error');
                    }
                }
            },
            responsive: true,
            pageLength: 10,
            order: [[2, 'desc']],
            language: {
                processing: "‚è≥ Loading...",
                search: "Search:",
                lengthMenu: "Show _MENU_",
                paginate: { first: "¬´", last: "¬ª", next: "‚Ä∫", previous: "‚Äπ" },
                zeroRecords: "No data",
                info: "_START_ to _END_ of _TOTAL_",
                infoEmpty: "0 to 0 of 0"
            },
            columns: [
                { data: 0, title: "File Name" },
                { data: 1, title: "Period" },
                { data: 2, title: "Upload Date" },
                { data: 3, title: "Status", orderable: false, searchable: false },
                { data: 4, title: "Download", orderable: false, searchable: false }
            ],
            drawCallback: function() {
                const rowCount = this.api().rows().count();
                console.log(`‚úÖ DataTable drawn: ${rowCount} rows`);
                
                // PERBAIKAN CRITICAL: Resume polling dengan task IDs dari API
                const inProgressTasks = dataTable.inProgressTasks || [];
                
                console.log(`üîÑ Calling extractAndResumePolling with ${inProgressTasks.length} tasks`);
                extractAndResumePolling(inProgressTasks);
            }
        });

        console.log('‚úÖ DataTable initialized');
        
    } catch (error) {
        console.error('‚ùå DataTable init failed:', error);
    }
});

// ==================== FORM HANDLING ====================

document.getElementById('uploadForm').addEventListener('submit', function(e) {
    e.preventDefault();
    
    const submitBtn = document.getElementById('submitBtn');
    const originalText = submitBtn.textContent;
    const form = this;
    const filename = document.getElementById('nama_file').value.trim();
    
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
    
    fetch('/check-filename', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 'nama_file': filename })
    })
    .then(response => response.json())
    .then(data => {
        if (data.exists) {
            showToast('Nama file sudah ada', 'warning');
            document.getElementById('filename-error').style.display = 'block';
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
        } else {
            showToast('Upload dimulai...', 'info');
            const formData = new FormData(form);
            
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
            
            fetch(form.action, {
                method: 'POST',
                body: formData,
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.json();
            })
            .then(uploadData => {
                console.log('üì• Upload response:', uploadData);
                
                if (uploadData && uploadData.task_id) {
                    console.log('‚úÖ Task ID received:', uploadData.task_id);
                    
                    // Start polling immediately
                    startAdaptivePolling(uploadData.task_id);
                    
                    // Reload DataTable
                    setTimeout(() => {
                        if (dataTable) {
                            console.log('üîÑ Reloading DataTable after upload');
                            dataTable.ajax.reload(null, false);
                        }
                    }, 500);
                }
                
                if (uploadData && uploadData.success) {
                    showToast('Upload berhasil dimulai', 'success');
                } else if (uploadData && uploadData.error) {
                    showToast(uploadData.error, 'error');
                }
            })
            .catch(err => {
                console.error('Upload error:', err);
                showToast('Terjadi kesalahan', 'error');
            });
        }
    })
    .catch(err => {
        console.error('Filename check error:', err);
        showToast('Terjadi kesalahan', 'error');
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
    });
});

// ==================== INITIALIZATION ====================

document.addEventListener('DOMContentLoaded', function() {
    console.log('üé¨ Initializing');
    
    // Start polling untuk tasks dari backend
    if (tasksFromBackend && Array.isArray(tasksFromBackend) && tasksFromBackend.length > 0) {
        console.log(`üìã Starting polling for ${tasksFromBackend.length} initial tasks`);
        tasksFromBackend.forEach(taskId => {
            if (!completedTasks.has(taskId)) {
                startAdaptivePolling(taskId);
            }
        });
    }
    
    // Periodic cleanup
    setInterval(() => {
        const now = Date.now();
        const STALE_THRESHOLD = 3600000; // 1 hour
        
        activePollingTasks.forEach((state, taskId) => {
            if (now - state.startTime > STALE_THRESHOLD) {
                console.log(`üßπ Cleaning stale polling: ${taskId}`);
                if (state.controller) {
                    try { state.controller.abort(); } catch (e) {}
                }
                activePollingTasks.delete(taskId);
            }
        });
    }, 60000);
});

// ==================== CLEANUP ====================

window.addEventListener('beforeunload', () => {
    console.log('üëã Page unloading');
    cleanupAllRequests();
});

document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
        console.log('üëÅÔ∏è Page visible - will resume on next DataTable draw');
    }
});
</script>

<script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}"></script>

{% endblock %}