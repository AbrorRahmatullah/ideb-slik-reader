{% extends "header.html" %}

{% block title %}Upload Files{% endblock %}

{% block content %}
<div class="card mb-4">
    <div class="card-header">
        <h5 class="mb-0">Upload Files More Than 10MB</h5>
    </div>
    <div class="card-body">
        <form id="uploadForm" action="/upload-big-size" method="POST" enctype="multipart/form-data">
            <div class="mb-3">
                <label for="flag" class="form-label">Select a Flag</label>
                <small class="text-danger">*Required</small> 
                <select name="flag" class="form-select" required>
                    <option value="" disabled selected>Select a flag</option>
                    {% for flag in flags %}
                    <option value="{{ flag }}">{{ flag }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="mb-3">
                <div class="d-flex flex-column">
                    <div class="d-flex align-items-center mb-1">
                        <label for="file" class="form-label me-2">Select Text File(s)</label>
                        <small class="text-danger">*Maksimal size file upload 200MB</small> 
                    </div>
                    <small class="text-success">
                        <i class="fas fa-exclamation-triangle"></i> Pastikan file yang diupload memiliki <strong>NPWP</strong> atau <strong>Nomor Identitas</strong> yang sama. Jika tidak sama, sistem <u>tidak akan memproses</u> file tersebut.
                    </small>
                </div>
                <input type="file" name="file" class="form-control mt-2" accept=".txt" multiple required>
            </div>
            <div class="mb-3">
                <label for="nama_file" class="form-label">Nama File</label>
                <small class="text-danger">*Required</small> 
                <input type="text" id="nama_file" name="nama_file" class="form-control" required>
                <div id="filename-error" class="text-danger mt-1" style="display: none;">
                    <small><i class="fas fa-exclamation-triangle"></i> Nama file sudah ada, harap masukkan nama file yang lain</small>
                </div>
            </div>
            <button type="submit" id="submitBtn" class="btn btn-primary">Upload</button>    
        </form>
    </div>
</div>

<div class="card mt-4">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">Data Upload</h5>
        <a href="{{ url_for('upload_big_size_file') }}" class="btn btn-info btn-sm">
            <i class="fas fa-sync-alt"></i> Refresh</a>
    </div>
    <div class="card-body">
        <div class="table-responsive" style="overflow-x: auto;">
            <table id="uploadTable" class="table table-bordered nowrap w-100">
                <thead>
                    <tr>
                        <th>Nama File Upload</th>
                        <th>Periode Data</th>
                        <th>Upload Date</th>
                        <th>Status</th>
                        <th>Download</th>
                    </tr>
                </thead>
                <tbody>
                    {% for item in data %}
                    {% set task_id = item.task_id %}
                    {% set task = task_progress.get(task_id) %}
                    
                    {% if task is mapping %}
                        {% set progress = task.get('progress', 0) %}
                        {% set status = task.get('status', 'processing') %}
                    {% else %}
                        {% if task_id and task_id != 'null' %}
                            {% set progress = 0 %}
                            {% set status = 'processing' %}
                        {% else %}
                            {% set progress = 100 %}
                            {% set status = 'completed' %}
                        {% endif %}
                    {% endif %}

                    <tr>
                        <td>{{ item.namaFileUpload|string }}</td>
                        <td>{{ item.periodeData|string }}</td>
                        <td class="text-nowrap" data-order="{{ item.uploadDate_raw|string }}">
                            {% if item.uploadDate %}
                                {{ item.uploadDate|string }}
                            {% else %}
                                N/A
                            {% endif %}
                        </td>
                        <td>
                            <div class="progress" style="height: 18px;">
                                <div id="progress-bar-{{ task_id or 'static-' ~ loop.index }}"
                                     class="progress-bar progress-bar-striped {{ 'progress-bar-animated' if progress < 100 and status != 'error' else '' }} {{ 'bg-danger' if status == 'error' else '' }}"
                                     role="progressbar" style="width: {{ progress }}%;"
                                     aria-valuenow="{{ progress }}" aria-valuemin="0" aria-valuemax="100">
                                    {{ 'Error' if status == 'error' else (progress ~ '%') }}
                                </div>
                            </div>
                        </td>
                        <td>
                            {% if progress == 100 and status != 'error' %}
                                <div class="btn-group">
                                    <a href="{{ url_for('download_big_size', periodeData=item.periodeData, username=item.username, namaFileUpload=item.namaFileUpload, uploadDate=item.uploadDate|string) }}"
                                       class="btn btn-outline-success btn-sm" title="Download Excel">Excel
                                        <i class="fas fa-file-excel"></i>
                                    </a>
                                    <a href="{{ url_for('download_upload_zip', periodeData=item.periodeData, username=item.username, namaFileUpload=item.namaFileUpload, uploadDate=item.uploadDate|string) }}"
                                       class="btn btn-outline-primary btn-sm" title="Download ZIP">ZIP
                                        <i class="fas fa-file-archive"></i>
                                    </a>
                                </div>
                            {% elif status == 'error' %}
                                <button id="download-btn-{{ task_id or 'static-' ~ loop.index }}" class="btn btn-danger btn-sm" disabled>
                                    <i class="fas fa-exclamation-triangle"></i> Error
                                </button>
                            {% else %}
                                <button id="download-btn-{{ task_id or 'static-' ~ loop.index }}" class="btn btn-secondary btn-sm" disabled>
                                    <i class="fas fa-spinner fa-spin"></i> Processing
                                </button>
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Base Modal -->
{% include "base_modal.html" with context %}

<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 9999">
    <div id="uploadToast" class="toast align-items-center text-white bg-info border-0" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="d-flex">
            <div class="toast-body">
                <i class="fas fa-spinner fa-spin me-2"></i> Upload sedang diproses...
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
    </div>
</div>

{% if task_id %}
    <script>
        const taskId = "{{ task_id }}";
        console.log("Assigned taskId for polling:", taskId);
    </script>
{% else %}
    <script>console.log("No taskId assigned");</script>
{% endif %}

<script>
    // Global variables and functions
    const errorList = {}; 
    const validationErrorList = {}; 
    let taskMetadataCache = {};
    let dataTable; // Global DataTable instance

    function ensureStringData(data) {
        if (data === null || data === undefined) {
            return '';
        }
        
        if (typeof data === 'object') {
            if (data instanceof Date) {
                try {
                    return data.toLocaleString('id-ID', {
                        day: '2-digit',
                        month: 'long',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } catch (e) {
                    return data.toString();
                }
            }
            // Jika object lain, convert ke JSON string
            try {
                return JSON.stringify(data);
            } catch (e) {
                return String(data);
            }
        }
        
        return String(data);
    }

    // Global function declarations - MOVED OUTSIDE OF DOCUMENT READY
    function updateOrAddRowToTable(taskId, filename, currentDate, metadata = null) {
        if (!dataTable) {
            console.warn('DataTable not available, skipping row update');
            return;
        }

        try {
            // Check if row already exists
            const existingRow = document.getElementById(`progress-bar-${taskId}`);
            if (existingRow) {
                const row = existingRow.closest('tr');
                const cells = row.querySelectorAll('td');
                
                if (metadata) {
                    // Update existing row data - PASTIKAN SEMUA DATA STRING
                    cells[0].textContent = ensureStringData(metadata.namaFileUpload || filename || '');
                    cells[1].textContent = ensureStringData(metadata.periodeData || '-');
                    cells[2].textContent = ensureStringData(metadata.uploadDate || currentDate || '');
                }
                return;
            }

            // PERBAIKAN: Pastikan semua data sudah dalam format string
            const displayName = ensureStringData(metadata?.namaFileUpload || filename);
            const displayPeriode = ensureStringData(metadata?.periodeData || '-');
            const displayDate = ensureStringData(metadata?.uploadDate || currentDate);
            const safeTaskId = String(taskId).replace(/[^a-zA-Z0-9-_]/g, '');

            // Create HTML content sebagai string
            const progressHtml = `
                <div class="progress" style="height: 18px;">
                    <div id="progress-bar-${safeTaskId}" 
                        class="progress-bar progress-bar-striped progress-bar-animated" 
                        role="progressbar" 
                        style="width: 0%;" 
                        aria-valuenow="0" 
                        aria-valuemin="0" 
                        aria-valuemax="100">
                        0%
                    </div>
                </div>
            `;

            const downloadHtml = `
                <button id="download-btn-${safeTaskId}" 
                        class="btn btn-secondary btn-sm" 
                        disabled>
                    <i class="fas fa-spinner fa-spin"></i> Processing
                </button>
            `;

            // PERBAIKAN: Pastikan rowData hanya berisi string
            const rowData = [
                displayName,      // string
                displayPeriode,   // string  
                displayDate,      // string
                progressHtml,     // string (HTML)
                downloadHtml      // string (HTML)
            ];

            console.log('Row data types:', rowData.map((item, i) => `Col${i}: ${typeof item} = "${item}"`));

            // Add row dengan validasi tambahan
            try {
                const newRow = dataTable.row.add(rowData);
                const rowNode = newRow.draw().node();
                
                // Move new row to top
                $(rowNode).prependTo(dataTable.table().body());
                dataTable.draw(false);
                
                console.log(`Row added successfully for task: ${taskId}`);
                
            } catch (addError) {
                console.error('Error adding row to DataTable:', addError);
                console.error('Row data causing error:', rowData);
                
                // Fallback: add row directly to DOM
                addRowDirectly(displayName, displayPeriode, displayDate, safeTaskId);
            }
            
        } catch (error) {
            console.error('Error in updateOrAddRowToTable:', error);
            console.error('Metadata causing error:', metadata);
        }
    }

    function addRowDirectly(displayName, displayPeriode, displayDate, safeTaskId) {
        try {
            const tableBody = document.querySelector('#uploadTable tbody');
            const newRow = document.createElement('tr');
            
            newRow.innerHTML = `
                <td>${displayName}</td>
                <td>${displayPeriode}</td>
                <td>${displayDate}</td>
                <td>
                    <div class="progress" style="height: 18px;">
                        <div id="progress-bar-${safeTaskId}" 
                            class="progress-bar progress-bar-striped progress-bar-animated" 
                            role="progressbar" 
                            style="width: 0%;" 
                            aria-valuenow="0" 
                            aria-valuemin="0" 
                            aria-valuemax="100">
                            0%
                        </div>
                    </div>
                </td>
                <td>
                    <button id="download-btn-${safeTaskId}" 
                            class="btn btn-secondary btn-sm" 
                            disabled>
                        <i class="fas fa-spinner fa-spin"></i> Processing
                    </button>
                </td>
            `;
            
            tableBody.insertBefore(newRow, tableBody.firstChild);
            console.log(`Row added directly for task: ${safeTaskId}`);
            
        } catch (directError) {
            console.error('Error adding row directly:', directError);
        }
    }

    function debugDataTableState() {
        console.log('=== DataTable Debug Info ===');
        console.log('Is DataTable:', $.fn.DataTable.isDataTable('#uploadTable'));
        console.log('Table element exists:', document.getElementById('uploadTable') !== null);
        
        if ($.fn.DataTable.isDataTable('#uploadTable')) {
            const table = $('#uploadTable').DataTable();
            console.log('Row count:', table.rows().count());
            console.log('Column count:', table.columns().count());
            
            // Check data types in each row
            table.rows().every(function(index) {
                const data = this.data();
                console.log(`Row ${index} data types:`, data.map((item, i) => `Col${i}: ${typeof item}`));
            });
        }
        console.log('==============================');
    }

    function removeTaskRow(taskId) {
        taskId = (taskId || "").trim();
        const table = $('#uploadTable').DataTable();

        // Find progress bar first
        let progressBar = document.getElementById(`progress-bar-${taskId}`);

        if (progressBar) {
            // If progress bar found → remove based on its row
            const row = progressBar.closest('tr');
            if (row) {
                table.row(row).remove().draw();
                console.log(`Removed row for task: ${taskId} (via progress bar)`);
            }
        } else {
            // If no progress bar → try to find from metadata
            let found = false;

            if (taskMetadataCache[taskId] && taskMetadataCache[taskId].namaFileUpload) {
                const filename = taskMetadataCache[taskId].namaFileUpload.trim();
                table.rows().every(function () {
                    if (String(this.data()[0]).trim() === filename) {
                        this.remove();
                        found = true;
                    }
                });
                if (found) {
                    table.draw();
                    console.log(`Removed row for task: ${taskId} (via metadata filename)`);
                }
            }

            // If metadata also not available, try to find based on first column containing taskId
            if (!found) {
                table.rows().every(function () {
                    const rowHtml = this.node().outerHTML;
                    if (rowHtml.includes(taskId)) {
                        this.remove();
                        found = true;
                    }
                });
                if (found) {
                    table.draw();
                    console.log(`Removed row for task: ${taskId} (via HTML contains taskId)`);
                } else {
                    console.warn(`Task row not found for task: ${taskId}`);
                }
            }
        }

        // Clear metadata cache
        delete taskMetadataCache[taskId];
    }

    // Get existing file names from the table for client-side check
    const existingFileNames = [
        {% for item in data %}
        "{{ item.namaFileUpload }}",
        {% endfor %}
    ];

    function showUploadStartedToast() {
        const toastEl = document.getElementById("uploadToast");
        const toast = new bootstrap.Toast(toastEl, { delay: 5000 });
        toast.show();
    }

    document.getElementById("uploadForm").addEventListener("submit", function (e) {
        showUploadStartedToast();
    });

    // Function to check if filename already exists
    function checkFilenameExists(filename) {
        return existingFileNames.includes(filename.trim());
    }

    // Function to show duplicate file alert
    function showDuplicateFileAlert() {
        const modal = new bootstrap.Modal(document.getElementById('duplicateFileModal'));
        modal.show();
    }

    // Real-time validation on input
    document.getElementById('nama_file').addEventListener('input', function() {
        const filename = this.value.trim();
        const errorDiv = document.getElementById('filename-error');
        const submitBtn = document.getElementById('submitBtn');
        
        if (filename && checkFilenameExists(filename)) {
            errorDiv.style.display = 'block';
            this.classList.add('is-invalid');
            submitBtn.disabled = true;
        } else {
            errorDiv.style.display = 'none';
            this.classList.remove('is-invalid');
            submitBtn.disabled = false;
        }
    });

    // Form submission validation
    document.getElementById('uploadForm').addEventListener('submit', function(e) {
        const filenameInput = document.getElementById('nama_file');
        const filename = filenameInput.value.trim();
        
        // Client-side check
        if (checkFilenameExists(filename)) {
            e.preventDefault();
            showDuplicateFileAlert();
            filenameInput.focus();
            return false;
        }
        
        // Server-side check via AJAX before actual form submission
        e.preventDefault();
        
        const submitBtn = document.getElementById('submitBtn');
        const originalText = submitBtn.textContent;
        
        // Show loading state
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
        
        // Check with server
        fetch('/check-filename', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 'nama_file': filename })
        })
        .then(response => response.json())
        .then(data => {
            if (data.exists) {
                showDuplicateFileAlert();
                filenameInput.focus();
                filenameInput.classList.add('is-invalid');
                document.getElementById('filename-error').style.display = 'block';
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            } else {
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';
                this.submit();
            }
        })
        .catch(error => {
            console.error('Error checking filename:', error);
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';
            showUploadStartedToast();
            this.submit();
        });
    });

    $(document).ready(function() {
        try {
            // Destroy existing table if exists
            if ($.fn.DataTable.isDataTable('#uploadTable')) {
                $('#uploadTable').DataTable().destroy();
            }

            dataTable = $('#uploadTable').DataTable({
                responsive: true,
                pageLength: 10,
                lengthMenu: [[10, 25, 50, 100, -1], [10, 25, 50, 100, "Semua"]],
                order: [[2, 'desc']],
                lengthChange: true,
                orderCellsTop: true,
                fixedHeader: true,
                language: {
                    search: "Cari:",
                    lengthMenu: "Tampilkan _MENU_ entri",
                    paginate: {
                        first: "Awal", last: "Akhir", next: "→", previous: "←"
                    },
                    zeroRecords: "Tidak ada data ditemukan",
                    info: "Menampilkan _START_ sampai _END_ dari _TOTAL_ data",
                    infoEmpty: "Menampilkan 0 dari 0 data"
                },
                columnDefs: [
                    { targets: [3, 4], orderable: false },
                    { 
                        targets: [0, 1, 2], 
                        type: 'string',
                        render: function(data, type, row) {
                            // PERBAIKAN: Pastikan render function mengembalikan string
                            if (type === 'display' || type === 'type') {
                                return ensureStringData(data);
                            }
                            // Untuk sorting dan filtering, pastikan juga string
                            return ensureStringData(data);
                        }
                    },
                    // TAMBAHAN: Pastikan kolom HTML juga di-handle dengan benar
                    {
                        targets: [3, 4],
                        render: function(data, type, row) {
                            if (type === 'display') {
                                return data; // HTML content
                            }
                            // Untuk sorting/filtering, kembalikan text content
                            if (typeof data === 'string' && data.includes('<')) {
                                // Extract text dari HTML
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = data;
                                return tempDiv.textContent || tempDiv.innerText || '';
                            }
                            return ensureStringData(data);
                        }
                    }
                ],
                // PERBAIKAN: Tambahkan error handling yang lebih detail
                error: function(xhr, error, code) {
                    console.error('DataTable error:', { xhr, error, code });
                    console.error('Table data:', dataTable ? dataTable.data().toArray() : 'N/A');
                    
                    // Log semua row data untuk debugging
                    if (dataTable) {
                        dataTable.rows().every(function(index) {
                            const data = this.data();
                            console.error(`Row ${index} data:`, data);
                            console.error(`Row ${index} types:`, data.map(item => typeof item));
                        });
                    }
                },
                // TAMBAHAN: Pre-processing untuk memastikan data konsisten
                rowCallback: function(row, data, index) {
                    // Validasi data setiap row
                    for (let i = 0; i < data.length; i++) {
                        if (typeof data[i] === 'object' && data[i] !== null && !data[i].toString().includes('<')) {
                            console.warn(`Row ${index}, Col ${i} contains object:`, data[i]);
                            // Convert object ke string
                            data[i] = ensureStringData(data[i]);
                        }
                    }
                    return row;
                }
            });

            console.log('DataTable initialized successfully');
            
        } catch (error) {
            console.error('Failed to initialize DataTable:', error);
        }
    });

    document.addEventListener("DOMContentLoaded", function () {
        // Get all task IDs (filter out null/empty values)
        const rawTaskIds = {{ data | map(attribute='task_id') | list | tojson }};
        const taskIds = rawTaskIds.filter(id => {
            return id && 
                id !== null && 
                id !== "null" && 
                id !== "None" && 
                id !== "undefined" &&
                typeof id === 'string' && 
                id.toString().trim() !== "" &&
                id.toString().trim() !== "None" &&
                id.toString().trim() !== "null";
        });

        const completedTasks = new Set();
        let activeTaskCount = 0;

        taskIds.forEach(taskId => {
            const bar = document.getElementById(`progress-bar-${taskId}`);
            if (bar) {
                const progress = parseInt(bar.getAttribute("aria-valuenow") || "0");
                const isError = bar.classList.contains("bg-danger");
                
                if (progress >= 100 || isError) {
                    completedTasks.add(taskId);
                } else {
                    activeTaskCount++;
                }
            }
        });
        
        const sessionTaskId = "{{ task_id }}";
        if (sessionTaskId &&
            sessionTaskId !== "None" &&
            sessionTaskId !== "null" &&
            sessionTaskId.trim() !== "") {
            
            if (!taskIds.includes(sessionTaskId)) {
                taskIds.push(sessionTaskId);
                const sessionBar = document.getElementById(`progress-bar-${sessionTaskId}`);
                if (!sessionBar || parseInt(sessionBar.getAttribute("aria-valuenow") || "0") < 100) {
                    activeTaskCount++;
                }
            }
        }

        const filteredTaskIds = taskIds.filter(taskId => {
            const bar = document.getElementById(`progress-bar-${taskId}`);
            if (!bar) return true;

            const progress = parseInt(bar.getAttribute("aria-valuenow") || "0");
            const isError = bar.classList.contains("bg-danger");

            if (progress >= 100 || isError) {
                completedTasks.add(taskId);
                return false;
            }
            return true;
        });

        console.log("Valid Task IDs found:", taskIds);
        console.log("Filtered Task IDs for polling:", filteredTaskIds);
        console.log(`Initial status: ${completedTasks.size} completed tasks, ${activeTaskCount} active tasks`);

        function showToast(message, type = 'success') {
            const toastEl = document.getElementById('uploadToast');
            const toastBody = toastEl.querySelector('.toast-body');

            toastBody.innerHTML = message;

            // Change background according to notification type
            toastEl.classList.remove('bg-success', 'bg-danger', 'bg-warning', 'bg-info');

            if (type === 'error') {
                toastEl.classList.add('bg-danger');
                toastBody.innerHTML = '<i class="fas fa-times-circle me-2"></i>' + message;
            } else if (type === 'warning') {
                toastEl.classList.add('bg-warning');
                toastBody.innerHTML = '<i class="fas fa-exclamation-triangle me-2"></i>' + message;
            } else if (type === 'info') {
                toastEl.classList.add('bg-info');
                toastBody.innerHTML = '<i class="fas fa-info-circle me-2"></i>' + message;
            } else {
                toastEl.classList.add('bg-success');
                toastBody.innerHTML = '<i class="fas fa-check-circle me-2"></i>' + message;
            }

            const toast = new bootstrap.Toast(toastEl, { delay: 5000 });
            toast.show();
        }

        // Modal functions
        function showSuccessNotificationModal(message) {
            console.log("Showing success toast:", message);
            showToast(message, 'success');
        }

        function showErrorNotificationModal(message) {
            console.log("Showing error toast:", message);
            showToast(message, 'error');
        }

        function showValidationErrorModal(message) {
            console.log("Showing warning toast (validation):", message);
            showToast(message, 'warning');
        }

        // Handle task completion
        function handleTaskCompletion(taskId, isError = false, errorMessage = "") {
            if (completedTasks.has(taskId)) return;
            completedTasks.add(taskId);

            if (sessionStorage.getItem(`popup_shown_${taskId}`)) return;
            sessionStorage.setItem(`popup_shown_${taskId}`, 'true');
            
            activeTaskCount = Math.max(0, activeTaskCount - 1);

            if (isError) {
                const errorType = errorList[taskId]?.type || "general_error";
                
                const isValidationError = errorType === "validation_error" || 
                                        errorMessage.includes("NPWP") || 
                                        errorMessage.includes("tidak konsisten") ||
                                        errorMessage.includes("validation") ||
                                        errorMessage.includes("Identitas");
                
                if (isValidationError) {
                    showValidationErrorModal(errorMessage);
                } else {
                    showErrorNotificationModal(errorMessage);
                }
            } else {
                if (activeTaskCount > 0) {
                    showSuccessNotificationModal("File berhasil diupload! Masih ada proses upload lain yang sedang berjalan.");
                }
            }

            // Check if all tasks are completed
            if (activeTaskCount <= 0) {
                const totalErrors = Object.keys(errorList).length;
                const totalTasks = taskIds.length;

                setTimeout(() => {
                    if (totalErrors === totalTasks && totalTasks > 0) {
                        showErrorNotificationModal("Semua proses upload gagal. Periksa file yang diupload!");
                    } else if (totalErrors > 0) {
                        showErrorNotificationModal("Proses upload selesai, namun beberapa file mengalami error.");
                    } else if (!isError && totalTasks > 0) {
                        showSuccessNotificationModal("Semua file berhasil diupload dan diproses!");
                    }
                }, 500);
            }
        }

        // Handle task error UI updates
        function handleTaskError(taskId, errorMessage = "Error", errorType = "general_error") {
            const progressBar = document.getElementById(`progress-bar-${taskId}`);
            const downloadBtn = document.getElementById(`download-btn-${taskId}`);
            
            if (progressBar) {
                progressBar.classList.remove("progress-bar-animated");
                progressBar.classList.add("bg-danger");
                progressBar.style.width = "100%";
                progressBar.innerText = "Error";
                progressBar.setAttribute("aria-valuenow", "100");
            }
            
            if (downloadBtn) {
                downloadBtn.disabled = true;
                downloadBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Error';
                downloadBtn.classList.remove("btn-primary", "btn-secondary");
                downloadBtn.classList.add("btn-danger");
            }

            // Store error info
            errorList[taskId] = { message: errorMessage, type: errorType };
        }

        // Handle task success UI updates
        function handleTaskSuccess(taskId) {
            const progressBar = document.getElementById(`progress-bar-${taskId}`);
            const downloadBtn = document.getElementById(`download-btn-${taskId}`);
            
            if (progressBar) {
                progressBar.classList.remove("progress-bar-animated");
                progressBar.style.width = "100%";
                progressBar.innerText = "100%";
                progressBar.setAttribute("aria-valuenow", "100");
            }
            
            if (downloadBtn) {
                // Get metadata from JavaScript cache
                const taskMetadata = taskMetadataCache[taskId];
                
                if (taskMetadata) {
                    const namaFile = encodeURIComponent(taskMetadata.namaFileUpload || 'Unknown');
                    const periode = encodeURIComponent(taskMetadata.periodeData || '-');
                    const uploadDate = encodeURIComponent(taskMetadata.uploadDate || new Date().toISOString());
                    const username = encodeURIComponent(taskMetadata.username || '');

                    console.log("Creating download buttons with metadata:", {
                        namaFile: taskMetadata.namaFileUpload,
                        periode: taskMetadata.periodeData,
                        uploadDate: taskMetadata.uploadDate,
                        username: taskMetadata.username
                    });
                    
                    // Update filename and periode in table columns
                    const row = downloadBtn.closest('tr');
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 2) {
                        cells[0].textContent = taskMetadata.namaFileUpload;
                        cells[1].textContent = taskMetadata.periodeData;
                    }
                    
                    // Create download buttons
                    downloadBtn.outerHTML = `
                        <div class="btn-group">
                            <a href="/download-big-size?periodeData=${periode}&username=${username}&namaFileUpload=${namaFile}&uploadDate=${uploadDate}"
                            class="btn btn-outline-success btn-sm" title="Download Excel">Excel
                               <i class="fas fa-file-excel"></i>
                           </a>
                           <a href="/download_upload?periodeData=${periode}&username=${username}&namaFileUpload=${namaFile}&uploadDate=${uploadDate}"
                           class="btn btn-outline-primary btn-sm" title="Download ZIP">ZIP
                               <i class="fas fa-file-archive"></i>
                           </a>
                       </div>
                   `;
               } else {
                   // Fallback if metadata not available
                   console.warn(`No metadata found for task ${taskId}, using fallback`);
                   
                   const row = downloadBtn.closest('tr');
                   const cells = row.querySelectorAll('td');
                   const namaFile = encodeURIComponent(cells[0].textContent.trim());
                   const periode = encodeURIComponent(cells[1].textContent.trim());
                   const uploadDate = encodeURIComponent(cells[2].textContent.trim());
                   
                   downloadBtn.outerHTML = `
                       <div class="btn-group">
                           <a href="/download-big-size?periodeData=${periode}&namaFileUpload=${namaFile}&uploadDate=${uploadDate}"
                           class="btn btn-outline-success btn-sm" title="Download Excel">Excel
                               <i class="fas fa-file-excel"></i>
                           </a>
                           <a href="/download_upload?periodeData=${periode}&namaFileUpload=${namaFile}&uploadDate=${uploadDate}"
                           class="btn btn-outline-primary btn-sm" title="Download ZIP">ZIP
                               <i class="fas fa-file-archive"></i>
                           </a>
                       </div>
                   `;
               }
           }
       }

       // Poll for task status updates
       console.log("Tasks to poll:", filteredTaskIds);
       if (!filteredTaskIds.includes(sessionTaskId)) {
           console.warn(`Session task ${sessionTaskId} tidak ikut dipolling!`);
       }

       if (filteredTaskIds.length > 0) {
           console.log(`Starting status polling for ${filteredTaskIds.length} tasks`);
           
           filteredTaskIds.forEach(taskId => {
               if (completedTasks.has(taskId)) {
                   console.log(`Skipping completed task: ${taskId}`);
                   return;
               }

               let progressBar = document.getElementById(`progress-bar-${taskId}`);
               if (!progressBar) {
                   console.log(`Creating new row for task: ${taskId}`);
                   updateOrAddRowToTable(taskId, 'Processing...', new Date().toLocaleString('id-ID'));
                   progressBar = document.getElementById(`progress-bar-${taskId}`);
               }

               const interval = setInterval(() => {
                    fetch(`/progress-status/${taskId}`)
                        .then(response => response.json())
                        .then(data => {
                            const progress = data.progress || 0;
                            const status = data.status || 'processing';
                            
                            // PERBAIKAN: Validasi dan sanitasi metadata
                            if (data.metadata) {
                                // Sanitasi metadata sebelum disimpan
                                const sanitizedMetadata = {};
                                Object.keys(data.metadata).forEach(key => {
                                    const value = data.metadata[key];
                                    sanitizedMetadata[key] = ensureStringData(value);
                                });
                                
                                taskMetadataCache[taskId] = sanitizedMetadata;
                                console.log(`Metadata cached for task ${taskId}:`, sanitizedMetadata);
                                
                                // Update row dengan metadata yang sudah di-sanitasi
                                updateOrAddRowToTable(taskId, sanitizedMetadata.namaFileUpload, 
                                                sanitizedMetadata.uploadDate, sanitizedMetadata);
                            }

                           console.log(`Polling task ${taskId}:`, data);

                           // Update progress bar
                           const currentProgressBar = document.getElementById(`progress-bar-${taskId}`);
                           if (currentProgressBar) {
                               currentProgressBar.style.width = `${progress}%`;
                               currentProgressBar.setAttribute('aria-valuenow', progress);
                               currentProgressBar.innerText = (status === 'error') ? 'Error' : `${progress}%`;
                               currentProgressBar.classList.toggle('progress-bar-animated', progress < 100 && status !== 'error');
                               currentProgressBar.classList.toggle('bg-danger', status === 'error');
                           }

                           // Handle response according to backend
                           if (data.completed && data.should_redirect) {
                               clearInterval(interval);
                               
                               if (data.error) {
                                   // Handle error response
                                   const errorMessage = data.error_message || data.message || 'Terjadi error saat memproses file';
                                   const errorType = data.error_type || 'general_error';

                                   console.log("Polling error terdeteksi1:", errorType, errorMessage);
                                   removeTaskRow(taskId);

                                   errorList[taskId] = { message: errorMessage, type: errorType };
                                   
                                   if (errorType === 'validation_error') {
                                       removeTaskRow(taskId);
                                   } else {
                                       handleTaskError(taskId, errorMessage, errorType);
                                   }
                                   
                                   handleTaskCompletion(taskId, true, errorMessage);
                               } else {
                                   // Handle success response
                                   if (data.metadata) {
                                       taskMetadataCache[taskId] = data.metadata;
                                   }
                                   
                                   handleTaskSuccess(taskId);
                                   handleTaskCompletion(taskId);
                               }
                           } else if (status === 'completed') {
                               // Fallback for old response without should_redirect
                               clearInterval(interval);
                               
                               if (data.metadata) {
                                   taskMetadataCache[taskId] = data.metadata;
                               }
                               
                               if (data.error_type === 'validation_error') {
                                   removeTaskRow(taskId);
                                   handleTaskCompletion(taskId, true, data.message || 'File validation error');
                               } else {
                                   handleTaskSuccess(taskId);
                                   handleTaskCompletion(taskId);
                               }
                           } else if (status === 'error') {
                               // Fallback for old error response
                               clearInterval(interval);
                               const errorMessage = data.message || 'Terjadi error saat memproses file';
                               const errorType = data.error_type || 'general_error';

                               console.log("Polling error terdeteksi:", errorType, errorMessage);
                               
                               errorList[taskId] = { message: errorMessage, type: errorType };
                               
                               if (errorType === 'validation_error') {
                                   removeTaskRow(taskId);
                               } else {
                                   handleTaskError(taskId, errorMessage, errorType);
                               }
                               
                               handleTaskCompletion(taskId, true, errorMessage);
                           } else if (status === 'not_found') {
                               // Handle task not found
                               clearInterval(interval);
                               console.warn(`Task ${taskId} not found on server`);
                               const errorMessage = "Task tidak ditemukan di server";
                               handleTaskError(taskId, errorMessage, "system_error");
                               handleTaskCompletion(taskId, true, errorMessage);
                           }
                       })
                       .catch(err => {
                           console.error(`Polling error for task ${taskId}:`, err);
                           clearInterval(interval);
                           const errorMessage = "Gagal mengambil status task";
                           handleTaskError(taskId, errorMessage, "system_error");
                           handleTaskCompletion(taskId, true, errorMessage);
                       });
               }, 3000); // Poll every 3 seconds
           });
       } else {
           console.log("No tasks to poll");
       }

       const hasValidUncompletedTasks = taskIds.some(id => {
           return id && 
               id !== 'None' && 
               id !== 'null' && 
               id !== 'undefined' &&
               id.trim() !== '' &&
               !completedTasks.has(id);
       });
   });
</script>
<script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}"></script>

{% endblock %}